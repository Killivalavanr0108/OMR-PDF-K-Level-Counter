<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>OMR OCR → Word (Debug Friendly)</title>

<!-- pdf.js worker setting handled below -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<!-- Tesseract (we use createWorker) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
<!-- docx (may be large) -->
<script src="https://cdn.jsdelivr.net/npm/docx@8.1.1/build/index.umd.js"></script>
<!-- file-saver for downloads -->
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<style>
  body,html{height:100%;margin:0;font-family:Arial;color:#e6fbff;background:#00181f;}
  .wrap{max-width:980px;margin:28px auto;padding:24px;background:rgba(0,10,20,0.45);
        border-radius:12px;box-shadow:0 8px 30px rgba(0,200,255,0.08);}
  h1{color:#00eaff;text-shadow:0 0 10px rgba(0,234,255,0.12)}
  .row{display:flex;gap:12px;align-items:center;margin:12px 0;}
  input[type=file]{color:#00eaff}
  #status{padding:12px;background:rgba(255,255,255,0.03);border-radius:8px;color:#cfeff7;}
  #student-info,#results{margin-top:12px;padding:12px;background:rgba(255,255,255,0.03);border-radius:8px;color:#cfeff7}
  button{background:#00eaff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:700}
  pre{white-space:pre-wrap;color:#bfefff}
  table{color:#dff; border-collapse:collapse}
  td,th{border:1px solid rgba(0,200,255,0.12);padding:6px 8px}
</style>
</head>
<body>
<div class="wrap">
  <h1>OMR OCR → Word (Debug)</h1>
  <div class="row">
    <input id="fileInput" type="file" accept=".pdf">
    <button id="startBtn">Start OCR</button>
    <button id="downloadBtn" style="display:none">⬇️ Download Word Report</button>
  </div>

  <div id="status">Status: waiting for file...</div>
  <div id="student-info"></div>
  <div id="results"></div>

  <h3>Console / Debug log (open DevTools if something fails)</h3>
  <pre id="logArea"></pre>
</div>

<script>
(async ()=>{

// --- Helpful debug logger to page and console
function log(msg){
  console.log(msg);
  const el = document.getElementById('logArea');
  el.textContent += msg + "\n";
  el.scrollTop = el.scrollHeight;
}

// --- Make sure pdf.js worker is set
pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
log("pdf.js workerSrc set.");

// DOM
const fileInput = document.getElementById('fileInput');
const startBtn = document.getElementById('startBtn');
const downloadBtn = document.getElementById('downloadBtn');
const statusEl = document.getElementById('status');

let lastOCR = { text: "", info: null, results: null };

// UI helpers
function setStatus(s){ statusEl.textContent = "Status: " + s; log(s); }
function showInfo(info){
  const out = document.getElementById('student-info');
  out.innerHTML = `<h3>Student Info</h3>
  <table><tr><th>Field</th><th>Value</th></tr>
  <tr><td>Name</td><td>${info.studentName||'Not found'}</td></tr>
  <tr><td>Register No</td><td>${info.regNo||'Not found'}</td></tr>
  <tr><td>Department</td><td>${info.department||'Not found'}</td></tr>
  <tr><td>Subject</td><td>${info.subjectName||'Not found'}</td></tr>
  <tr><td>Subject Code</td><td>${info.subjectCode||'Not found'}</td></tr>
  </table>`;
}
function showResults(results){
  const out = document.getElementById('results');
  const counts = results.counts;
  let html = `<h3>K-level Summary</h3><table><tr><th>K</th><th>Count</th></tr>`;
  ["K1","K2","K3","K4","K5","K6"].forEach(k => html += `<tr><td>${k}</td><td>${counts[k]||0}</td></tr>`);
  html += `</table><p>Total answered: <b>${results.total}</b> — Unanswered: <b>${results.unanswered}</b></p>`;
  html += "<h4>Per-question</h4><ol>";
  results.details.forEach(d=> html += `<li>Q${d.q}: ${d.pickedK || 'Unanswered'}</li>`);
  html += "</ol>";
  out.innerHTML = html;
}

// --- Robust OCR extraction using Tesseract worker
async function extractTextWithTesseractFromPDF(file){
  setStatus("Loading PDF...");
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  log(`PDF pages: ${pdf.numPages}`);

  // create tesseract worker once
  setStatus("Initializing OCR worker...");
  const { createWorker } = Tesseract;
  const worker = createWorker({
    logger: m => {
      // show progress for each page OCR
      if (m.status && m.progress!=null) setStatus(`${m.status} ${(m.progress*100).toFixed(0)}%`);
      log("Tess: " + JSON.stringify(m));
    }
  });

  await worker.load();
  await worker.loadLanguage('eng');
  await worker.initialize('eng');

  let aggregateText = "";
  for(let p=1; p<=pdf.numPages; p++){
    setStatus(`Rendering page ${p}/${pdf.numPages}`);
    const page = await pdf.getPage(p);
    const viewport = page.getViewport({ scale: 2.0 });
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(viewport.width);
    canvas.height = Math.round(viewport.height);
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
    setStatus(`OCR page ${p} ...`);
    const { data: { text } } = await worker.recognize(canvas);
    log(`OCR page ${p} length=${text.length}`);
    aggregateText += `\n\n--- PAGE ${p} ---\n` + text;
  }

  setStatus("Terminating OCR worker...");
  await worker.terminate();
  setStatus("OCR finished.");
  return aggregateText;
}

// --- More tolerant K-level parser
function parseStudentInfoFromText(text){
  // normalize spaces
  const t = text.replace(/\r/g,'\n').replace(/\n+/g,'\n').replace(/[ \t]+/g,' ').trim();
  // try common patterns
  const nameMatch = t.match(/Student\s*Name[:.\- ]+\s*([A-Za-z\u0B80-\u0BFF .]{2,80})/i);
  const regMatch = t.match(/Register\s*(?:No|No.)[:.\- ]+\s*([A-Za-z0-9\-\/]+)/i);
  const deptMatch = t.match(/Department[:.\- ]+\s*([A-Za-z0-9 .\-]{2,60})/i);
  const subjNameMatch = t.match(/Subject\s*Name[:.\- ]+\s*([A-Za-z0-9 .\-]{2,80})/i);
  const subjCodeMatch = t.match(/Subject\s*Code[:.\- ]+\s*([A-Za-z0-9\-]+)/i);

  return {
    studentName: nameMatch ? nameMatch[1].trim() : null,
    regNo: regMatch ? regMatch[1].trim() : null,
    department: deptMatch ? deptMatch[1].trim() : null,
    subjectName: subjNameMatch ? subjNameMatch[1].trim() : null,
    subjectCode: subjCodeMatch ? subjCodeMatch[1].trim() : null
  };
}

function countKLevelsFromText(rawText){
  // Normalize some OCR quirks
  let text = rawText.replace(/\u00A0/g,' ').replace(/\r/g,'\n');
  // replace weird bullets with single char
  text = text.replace(/[•●◉]/g,'*');
  // split into question blocks by lines that start with number
  const blocks = text.split(/\n(?=\s*\d+\b)/);
  const counts = { K1:0,K2:0,K3:0,K4:0,K5:0,K6:0 };
  const details = [];

  blocks.forEach(block=>{
    const qMatch = block.match(/^\s*(\d{1,3})\b/);
    if(!qMatch) return;
    const q = qMatch[1];

    // find all "(...)" groups, reasonable OCR may produce variants but this is robust
    let choices = Array.from(block.matchAll(/\(([^)]{0,30})\)/g), m=> m[1].trim());
    // sometimes OCR uses other separators, try to vendor-split by 6 tokens if less
    if(choices.length < 6){
      // fallback: find tokens that resemble options like "K1 (o) (e) ..."
      // try splitting the line after the number
      const tail = block.substring(block.indexOf(qMatch[0]) + qMatch[0].length);
      // split by multiple spaces
      const parts = tail.split(/\s{2,}/).map(s=>s.trim()).filter(Boolean);
      // try to pick tokens that look like parenthesized or single-chars
      if(parts.length>=6){
        choices = parts.slice(0,6).map(p=>{
          // strip surrounding parentheses if any
          return (p.match(/^\(?(.+?)\)?$/)? p.match(/^\(?(.+?)\)?$/)[1] : p).trim();
        });
      }
    }

    // If still less than 6, skip (too noisy)
    if(choices.length < 6){
      // attempt to find 6 candidates by searching for single-letter tokens
      const tokens = block.split(/\s+/).filter(Boolean);
      // find substrings that look like '(o)' or single-letter tokens near each other
      const parens = block.match(/\(.{0,5}\)/g) || [];
      if(parens.length >=6) choices = parens.slice(0,6).map(p=>p.replace(/^\(|\)$/g,'').trim());
      else {
        // give up for this block but record unanswered
        details.push({ q, pickedK: null });
        return;
      }
    }

    // Decide which option is filled using heuristics:
    // Consider: a choice is filled if it contains any of:
    // letters other than 'o' (e.g. e, m, c), '*', 'x', '+', '/', '\', digits, or special bullet
    function isFilled(choice){
      if(!choice) return false;
      const s = choice.replace(/[() \t\r\n]/g,'').trim();
      if(!s) return false;
      // common 'empty' signs we treat as empty: 'o', 'O', '0'
      if (/^[oO0]+$/.test(s)) return false;
      // If contains bullets or star or x or letters -> filled
      if (/[●•*xX+×\/\\@]/.test(s)) return true;
      // letters that indicate mark like e, m, c (from your sample)
      if (/[emcE]/.test(s)) return true;
      // otherwise treat as not filled
      return false;
    }

    const pickIndex = choices.findIndex(ch => isFilled(ch));
    if(pickIndex >= 0){
      const k = `K${pickIndex+1}`;
      if(counts[k] !== undefined) counts[k] += 1;
      details.push({ q, pickedK: k });
    } else {
      details.push({ q, pickedK: null });
    }
  });

  const total = Object.values(counts).reduce((a,b)=>a+b,0);
  const unanswered = details.filter(d=>!d.pickedK).length;
  return { counts, total, unanswered, details };
}

// --- Start OCR button
startBtn.addEventListener('click', async ()=>{
  const file = fileInput.files[0];
  if(!file){
    alert("Please choose a PDF first.");
    return;
  }

  // VERY IMPORTANT: If you opened the HTML as file://, Tesseract/pdfjs worker loads may fail.
  setStatus("Starting OCR pipeline...");
  log("Tip: If this hangs or fails, run this page via a local web server (python -m http.server).");
  try{
    const ocrText = await extractTextWithTesseractFromPDF(file);
    log("Full OCR length: " + ocrText.length);
    // parse info
    const info = parseStudentInfoFromText(ocrText);
    const results = countKLevelsFromText(ocrText);
    lastOCR = { text: ocrText, info, results };
    showInfo(info);
    showResults(results);
    setStatus("OCR done. You can download a Word report.");
    downloadBtn.style.display = "inline-block";
  }catch(err){
    setStatus("ERROR during OCR: see console");
    log("ERROR: " + (err && err.message ? err.message : String(err)));
  }
});

// --- Word generation (docx). Fallback to plain .doc if docx lib missing
downloadBtn.addEventListener('click', async ()=>{
  if(!lastOCR || !lastOCR.text){
    alert("No OCR result to export. Run OCR first.");
    return;
  }
  setStatus("Generating Word file...");
  try{
    if(typeof docx !== 'undefined' && docx.Document){
      const { Document, Packer, Paragraph, HeadingLevel, Table, TableRow, TableCell, TextRun } = docx;
      const doc = new Document();
      // Header
      doc.addSection({
        properties: {},
        children: [
          new Paragraph({ text: "OMR OCR Report", heading: HeadingLevel.HEADING_1 }),
          new Paragraph({ text: `Student Name: ${lastOCR.info.studentName || 'Not found'}` }),
          new Paragraph({ text: `Register No: ${lastOCR.info.regNo || 'Not found'}` }),
          new Paragraph({ text: `Department: ${lastOCR.info.department || 'Not found'}` }),
          new Paragraph({ text: `Subject: ${lastOCR.info.subjectName || 'Not found'}` }),
          new Paragraph({ text: `Subject Code: ${lastOCR.info.subjectCode || 'Not found'}` }),
          new Paragraph({ text: "" }),
          new Paragraph({ text: "K-Level Summary", heading: HeadingLevel.HEADING_2 }),
        ]
      });

      // Add K-level table
      const rows = [
        new TableRow({ children: [ new TableCell({ children: [ new Paragraph("K-Level") ] }), new TableCell({ children:[ new Paragraph("Count") ] }) ] })
      ];
      ["K1","K2","K3","K4","K5","K6"].forEach(k=>{
        rows.push(new TableRow({ children: [ new TableCell({ children:[ new Paragraph(k) ] }), new TableCell({ children:[ new Paragraph(String(lastOCR.results.counts[k] || 0)) ] }) ] }));
      });
      rows.push(new TableRow({ children: [ new TableCell({ children:[ new Paragraph("Total Answered") ] }), new TableCell({ children:[ new Paragraph(String(lastOCR.results.total)) ] }) ] }));
      rows.push(new TableRow({ children: [ new TableCell({ children:[ new Paragraph("Unanswered") ] }), new TableCell({ children:[ new Paragraph(String(lastOCR.results.unanswered)) ] }) ] }));

      const table = new Table({ rows });
      doc.addSection({ children: [table, new Paragraph({ text: "" }), new Paragraph({ text: "Per-question answers", heading: HeadingLevel.HEADING_2 }) ] });

      // per-question list as paragraphs
      lastOCR.results.details.forEach(d=>{
        doc.addSection({ children: [ new Paragraph({ text: `Q${d.q}: ${d.pickedK || 'Unanswered'}` }) ] });
      });

      // final: OCR raw text (shortened or full)
      doc.addSection({ children: [ new Paragraph({ text: "", }), new Paragraph({ text: "OCR Extracted Text (full)", heading: HeadingLevel.HEADING_2 }), new Paragraph({ text: lastOCR.text.slice(0,10000) }), new Paragraph({ text: "...(truncated)" }) ] });

      const blob = await Packer.toBlob(doc);
      saveAs(blob, `OMR_Report_${lastOCR.info.regNo||'student'}.docx`);
      setStatus("Word file generated & download started.");
      log("Word created (docx library).");
    } else {
      // fallback: plain text file saved as .doc (Word will open)
      const plain = `OMR OCR Report\n\nStudent Name: ${lastOCR.info.studentName||''}\nRegister No: ${lastOCR.info.regNo||''}\n\nK-level counts: ${JSON.stringify(lastOCR.results.counts,null,2)}\n\n---OCR Text---\n\n${lastOCR.text}`;
      const blob = new Blob([plain], { type: "application/msword" });
      saveAs(blob, `OMR_Report_${lastOCR.info.regNo||'student'}.doc`);
      setStatus("Plain .doc file generated (docx lib not found).");
      log("Fallback plain .doc saved.");
    }
  }catch(err){
    setStatus("ERROR generating Word: check console.");
    log("ERROR Word: " + (err && err.message ? err.message : String(err)));
  }
});

})(); // end IIFE
</script>
</body>
</html>
