<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>K-Level Counter – Smart OMR Reader</title>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.1/dist/tesseract.min.js"></script>
<script async src="https://docs.opencv.org/4.7.0/opencv.js"></script>

<style>
body {
  font-family: "Segoe UI", sans-serif;
  background: #f6f8fb;
  padding: 20px;
}
.container {
  max-width: 950px;
  margin: auto;
  background: #fff;
  padding: 25px;
  border-radius: 12px;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}
h1 {
  text-align: center;
  color: #007bff;
}
#fileInput {
  display: block;
  margin: 20px auto;
  padding: 10px;
}
#status {
  text-align: center;
  font-weight: bold;
  color: #333;
  margin-bottom: 10px;
}
.result-box {
  background: #eef7ff;
  padding: 15px;
  border-radius: 10px;
  margin-top: 15px;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}
th, td {
  border: 1px solid #007bff33;
  padding: 8px;
  text-align: center;
}
th {
  background: #007bff11;
}
.answered { color: green; font-weight: bold; }
.unanswered { color: red; font-weight: bold; }
</style>
</head>

<body>
<div class="container">
  <h1>🧮 K-Level Counter – Smart OMR Reader</h1>
  <p style="text-align:center;">Upload an <b>OMR Image</b> or <b>PDF</b> (TNPSC style).</p>
  <input type="file" id="fileInput" accept=".pdf,.jpg,.jpeg,.png">
  <div id="status"></div>
  <div id="results"></div>
</div>

<script>
document.getElementById("fileInput").addEventListener("change", handleFile);

async function handleFile(event) {
  const file = event.target.files[0];
  const ext = file.name.split('.').pop().toLowerCase();
  const status = document.getElementById("status");
  const results = document.getElementById("results");

  status.textContent = "⏳ Processing " + file.name + "...";
  results.innerHTML = "";

  try {
    let imageData;
    if (ext === "pdf") {
      imageData = await pdfToImage(file);
    } else if (["jpg", "jpeg", "png"].includes(ext)) {
      imageData = await readImage(file);
    } else {
      throw new Error("Unsupported file type.");
    }

    status.textContent = "🔍 Running OCR and Bubble Analysis...";
    const text = await extractText(imageData);
    const visualCount = await detectBubbles(imageData);
    displayResults(text, visualCount);
    status.textContent = "✅ Done!";
  } catch (err) {
    console.error(err);
    status.textContent = "❌ Error: " + err.message;
  }
}

// Convert PDF to image
async function pdfToImage(file) {
  const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({ scale: 2 });
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = viewport.width;
  canvas.height = viewport.height;
  await page.render({ canvasContext: ctx, viewport: viewport }).promise;
  return canvas.toDataURL("image/png");
}

// Read uploaded image
async function readImage(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.readAsDataURL(file);
  });
}

// OCR using Tesseract
async function extractText(imageData) {
  const result = await Tesseract.recognize(imageData, "eng", {
    logger: info => {
      document.getElementById("status").textContent = `🔍 OCR Progress: ${Math.round(info.progress * 100)}%`;
    }
  });
  return result.data.text;
}

// Visual detection using OpenCV
async function detectBubbles(imageData) {
  return new Promise((resolve) => {
    let img = new Image();
    img.onload = function () {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      let src = cv.imread(canvas);
      let gray = new cv.Mat();
      let blur = new cv.Mat();
      let binary = new cv.Mat();

      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      cv.GaussianBlur(gray, blur, new cv.Size(3, 3), 0, 0);
      cv.threshold(blur, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let counts = { K1: 0, K2: 0, K3: 0, K4: 0, K5: 0, K6: 0 };
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if (area > 200 && area < 2000) { // bubble size filter
          const rect = cv.boundingRect(cnt);
          const yPos = rect.y / img.height;
          // Approximate bubble positions into K1–K6 bands
          if (yPos < 0.16) counts.K1++;
          else if (yPos < 0.33) counts.K2++;
          else if (yPos < 0.50) counts.K3++;
          else if (yPos < 0.66) counts.K4++;
          else if (yPos < 0.83) counts.K5++;
          else counts.K6++;
        }
      }

      src.delete(); gray.delete(); blur.delete(); binary.delete(); contours.delete(); hierarchy.delete();
      resolve(counts);
    };
    img.src = imageData;
  });
}

// Display combined result
function displayResults(text, visualCount) {
  const results = document.getElementById("results");

  const details = {
    registerNo: (text.match(/Register\s*No[:.]?\s*(\d+)/i) || [])[1] || "Not found",
    subjectCode: (text.match(/Subject\s*Code[:.]?\s*([A-Za-z0-9]+)/i) || [])[1] || "Not found",
    college: (text.match(/College\s*Name[:.]?\s*(.+)/i) || [])[1] || "Not found"
  };

  const totalAnswered = Object.values(visualCount).reduce((a,b)=>a+b,0);

  results.innerHTML = `
  <div class="result-box">
    <h3>📋 Student Details</h3>
    <b>College:</b> ${details.college}<br>
    <b>Subject Code:</b> ${details.subjectCode}<br>
    <b>Register No:</b> ${details.registerNo}<br><hr>

    <h3>📊 K-Level Counter</h3>
    <table>
      <tr><th>K-Level</th><th>Detected Bubbles</th></tr>
      ${Object.entries(visualCount).map(([k,v])=>`<tr><td>${k}</td><td>${v}</td></tr>`).join('')}
      <tr><td><b>Total Answered</b></td><td><b>${totalAnswered}</b></td></tr>
    </table>
  </div>`;
}
</script>
</body>
</html>
